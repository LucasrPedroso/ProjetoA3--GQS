üßæ Relat√≥rio T√©cnico: An√°lise do C√≥digo Legado legacy_system.py
üìò Objetivo do C√≥digo

O arquivo legacy_system.py simula um sistema legado de usu√°rios, pedidos e pagamentos, implementado de forma intencionalmente incorreta para demonstrar m√°s pr√°ticas de programa√ß√£o orientada a objetos e viola√ß√£o de princ√≠pios de design.

‚öôÔ∏è Sum√°rio dos Problemas Identificados
Categoria	Problema	Consequ√™ncia
Arquitetura	Uso de vari√°veis globais (GLOBAL_CONFIG, DB, LOGGER)	Alto acoplamento, dif√≠cil manuten√ß√£o
Design Pattern	Singleton mal implementado	Inst√¢ncias m√∫ltiplas e imprevis√≠veis
Boas pr√°ticas	Execu√ß√£o de c√≥digo no import	Efeitos colaterais inesperados
POO	Classes com m√∫ltiplas responsabilidades	Viola SRP (Single Responsibility Principle)
Seguran√ßa	Uso de eval() e exec()	Possibilidade de execu√ß√£o de c√≥digo arbitr√°rio
Tratamento de erros	except Exception: pass	Oculta√ß√£o de falhas cr√≠ticas
Acoplamento	Depend√™ncia direta entre m√≥dulos	Dificulta testes unit√°rios
Estrutura de dados	Banco de dados em lista e arquivo JSON sem controle	Falta de integridade dos dados
Heran√ßa	Hierarquia desnecessariamente profunda (User ‚Üí Admin ‚Üí SuperAdmin)	Viola LSP (Liskov Substitution Principle)
Testabilidade	C√≥digo n√£o modular e sem inje√ß√£o de depend√™ncias	Dificuldade de teste isolado
Naming	Nomes amb√≠guos (save, do_purchase, state)	C√≥digo confuso e pouco sem√¢ntico
üîç An√°lise Detalhada por Se√ß√£o
1. üîß Configura√ß√£o Global
GLOBAL_CONFIG = {'db_path': '/tmp/fake_db.json', 'retry_count': 3, 'debug': True}


Problemas:

Uso de vari√°vel global mut√°vel (viola√ß√£o do encapsulamento).

Valor compartilhado por todo o sistema sem controle de acesso.

Falta de valida√ß√£o de tipos e integridade.

Corre√ß√£o:

Criar uma classe Config imut√°vel ou usar dataclass(frozen=True).

Passar a configura√ß√£o via inje√ß√£o de depend√™ncia.

2. üß± Classe Logger
self.f = open('/tmp/legacy_log.txt', 'a')


Problemas:

Efeito colateral no construtor (abre arquivo ao instanciar).

Ignora exce√ß√µes cr√≠ticas silenciosamente.

Implementa√ß√£o de singleton incorreta (usa inst√¢ncia global, n√£o controle interno).

Falta de fechamento do arquivo (close() nunca √© chamado).

Corre√ß√£o:

Implementar Singleton corretamente com @staticmethod ou @classmethod.

Encapsular abertura/fechamento de arquivos com with.

Substituir por m√≥dulo padr√£o logging do Python.

3. üóÉÔ∏è Classe Database
self._data = []


Problemas:

Persist√™ncia em lista na mem√≥ria (n√£o confi√°vel).

Escrita direta em JSON sem controle de concorr√™ncia.

Falta de tratamento de erros espec√≠ficos.

Coupling com GLOBAL_CONFIG.

M√©todos save() e query_all() sem encapsulamento real.

Corre√ß√£o:

Implementar padr√£o Repository ou DAO.

Criar camadas: DatabaseInterface, JSONDatabase.

Adicionar locks ou controle transacional.

Usar contextos (with open) e tratamento de erros espec√≠ficos.

4. üë§ Classe User

Problemas:

Responsabilidade m√∫ltipla (dados + persist√™ncia + envio de e-mail).

Uso de eval() inseguro:

template = "f'Hello {self.name}, {body} - {subject}'"
msg = eval(template)


Cria√ß√£o din√¢mica de atributos (setattr) inesperada.

Aus√™ncia de valida√ß√£o de tipos e e-mail.

Corre√ß√£o:

Separar em classes: User, UserRepository, EmailService.

Remover eval() ‚Üí usar f-string diretamente.

Evitar setattr ‚Üí criar atributo fixo session_token.

5. üß¨ Classes Admin e SuperAdmin

Problemas:

Heran√ßa desnecess√°ria e incorreta (Admin e SuperAdmin poderiam ser pap√©is, n√£o subclasses).

Viola o Princ√≠pio da Substitui√ß√£o de Liskov (SuperAdmin redefine comportamento destrutivo).

Armazena segredos em texto puro (self.secret_key).

Corre√ß√£o:

Usar composi√ß√£o (papel Role associado a User).

Proteger informa√ß√µes sens√≠veis.

Implementar permiss√µes via enum ou tabela de permiss√µes.

6. üì¶ Classe Order

Problemas:

M√©todo create_order() com m√∫ltiplas responsabilidades:

Cria pedido

Valida itens

Aplica desconto

Notifica usu√°rio

Persiste no banco

Viola√ß√£o do Princ√≠pio da Responsabilidade √önica (SRP).

L√≥gica duplicada em calculate_total().

Falta de valida√ß√£o de dados de entrada.

Corre√ß√£o:

Dividir em:

OrderService (neg√≥cio)

OrderRepository (persist√™ncia)

NotificationService

Centralizar l√≥gica de c√°lculo e valida√ß√£o.

7. üì£ Classe NotificationManager

Problemas:

if/elif gigante para cada tipo de evento (dif√≠cil de escalar).

Acoplada diretamente a User e LOGGER.

Falta de polimorfismo e extensibilidade.

Corre√ß√£o:

Usar Observer Pattern ou Strategy Pattern.

Criar classes espec√≠ficas de notifica√ß√£o:

OrderCreatedNotification

OrderFailedNotification

8. üí≥ Classe PaymentProcessor

Problemas:

Uso de eval() para processar m√©todos de pagamento.

Aceita qualquer string como c√≥digo Python.

Tratamento de exce√ß√µes gen√©rico e silencioso.

Falta de abstra√ß√£o (cada tipo de pagamento deveria ser uma classe separada).

Corre√ß√£o:

Usar Strategy Pattern:

PaymentProcessor

CardPayment

PaypalPayment

Remover completamente eval().

Retornar objetos de erro claros e logar com logging.

9. üß∞ Fun√ß√µes utilit√°rias (load_users, find_user_by_email)

Problemas:

Alto acoplamento com DB global.

Pesquisa linear O(n).

Falta de cache ou √≠ndice.

Tratamento de erro gen√©rico.

Corre√ß√£o:

Usar reposit√≥rio (UserRepository).

Implementar busca otimizada.

Lan√ßar exce√ß√µes espec√≠ficas (ex: UserNotFoundError).

10. üö® C√≥digo executado no import
print('legacy_system imported ‚Äî initializing demo data')


Problemas:

Efeito colateral ao importar o m√≥dulo.

Cria√ß√£o de objetos e escrita em disco sem controle.

Viola o princ√≠pio de ‚Äúimporta√ß√µes puras‚Äù.

Corre√ß√£o:

Mover a inicializa√ß√£o para um if __name__ == '__main__':.

Deixar o m√≥dulo import√°vel sem executar nada automaticamente.

11. üß© Fun√ß√£o p√∫blica do_purchase()

Problemas:

Mistura diversas camadas (dados, l√≥gica, notifica√ß√£o, pagamento).

Cria usu√°rios automaticamente sem valida√ß√£o.

Falta de tipagem, logs e testes.

Viola SRP, OCP e DIP.

Corre√ß√£o:

Reescrever como servi√ßo:

class PurchaseService:
    def __init__(self, user_repo, order_repo, payment_service, notifier):
        ...
    def execute(self, email, items):
        ...


Aplicar inje√ß√£o de depend√™ncia.

üß† Resumo dos Princ√≠pios Violados
Princ√≠pio	Nome	Viola√ß√£o
SRP	Single Responsibility	Classes com m√∫ltiplas fun√ß√µes
OCP	Open/Closed	C√≥digo dif√≠cil de estender sem modificar
LSP	Liskov Substitution	Subclasses com comportamento destrutivo
ISP	Interface Segregation	Nenhuma interface clara
DIP	Dependency Inversion	Uso de globais e inst√¢ncias fixas
‚úÖ Recomenda√ß√µes Gerais de Refatora√ß√£o

Substituir vari√°veis globais por inje√ß√£o de depend√™ncia.

Usar logging padr√£o do Python em vez de Logger caseiro.

Dividir o sistema em m√≥dulos separados (user.py, order.py, payment.py, etc).

Criar interfaces para persist√™ncia e servi√ßos.

Aplicar design patterns:

Strategy (pagamento, notifica√ß√µes)

Repository (persist√™ncia)

Observer (eventos)

Adicionar testes unit√°rios para cada componente.

Documentar as entidades e adicionar type hints.

Isolar l√≥gica de inicializa√ß√£o em main().